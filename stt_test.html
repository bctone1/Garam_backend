<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STT Test — gpt-4o-mini-transcribe</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Pretendard', -apple-system, sans-serif; background: #f5f5f5; padding: 2rem; color: #333; }
  h1 { font-size: 1.4rem; margin-bottom: .4rem; }
  .sub { color: #888; font-size: .85rem; margin-bottom: 1.5rem; }
  .card { background: #fff; border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem; box-shadow: 0 1px 4px rgba(0,0,0,.08); }
  .card h2 { font-size: 1rem; margin-bottom: 1rem; }
  label { display: block; font-size: .85rem; color: #555; margin-bottom: .3rem; }
  select, input[type=file] { width: 100%; padding: .5rem; border: 1px solid #ddd; border-radius: 6px; margin-bottom: .8rem; font-size: .9rem; }
  .row { display: flex; gap: .8rem; align-items: center; flex-wrap: wrap; }
  button { padding: .6rem 1.2rem; border: none; border-radius: 8px; font-size: .9rem; cursor: pointer; transition: .15s; }
  button:disabled { opacity: .4; cursor: not-allowed; }
  .btn-rec { background: #e53935; color: #fff; }
  .btn-rec.recording { background: #b71c1c; animation: pulse 1s infinite; }
  .btn-stop { background: #555; color: #fff; }
  .btn-send { background: #1976d2; color: #fff; }
  .btn-send:hover:not(:disabled) { background: #1565c0; }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.6} }
  #status { font-size: .85rem; color: #888; min-height: 1.2em; margin-top: .5rem; }
  #timer { font-variant-numeric: tabular-nums; font-size: .85rem; color: #e53935; min-width: 3em; }
  .result-box { background: #fafafa; border: 1px solid #eee; border-radius: 8px; padding: 1rem; margin-top: 1rem; min-height: 3rem; white-space: pre-wrap; word-break: break-word; font-size: .95rem; line-height: 1.6; display: none; }
  .result-box.show { display: block; }
  .result-box .label { font-size: .75rem; color: #999; margin-bottom: .4rem; }
  .meta { font-size: .8rem; color: #888; margin-top: .5rem; }
  audio { margin-top: .5rem; width: 100%; }
</style>
</head>
<body>

<h1>STT Test Page</h1>
<p class="sub">gpt-4o-mini-transcribe &middot; POST /llm/stt</p>

<!-- Settings -->
<div class="card">
  <h2>Settings</h2>
  <label for="baseUrl">API Base URL</label>
  <select id="baseUrl">
    <option value="http://localhost:5002">http://localhost:5002</option>
  </select>

  <label for="lang">Language</label>
  <select id="lang">
    <option value="ko-KR" selected>ko-KR (한국어)</option>
    <option value="en-US">en-US (English)</option>
    <option value="ja-JP">ja-JP (日本語)</option>
    <option value="zh-CN">zh-CN (中文)</option>
  </select>
</div>

<!-- Mic Recording -->
<div class="card">
  <h2>Mic Recording</h2>
  <div class="row">
    <button id="btnRec" class="btn-rec">Rec</button>
    <button id="btnStop" class="btn-stop" disabled>Stop</button>
    <span id="timer">0.0s</span>
    <button id="btnSendRec" class="btn-send" disabled>Send</button>
  </div>
  <audio id="audioPreview" controls style="display:none"></audio>
  <div id="status"></div>
</div>

<!-- File Upload -->
<div class="card">
  <h2>File Upload</h2>
  <label for="fileInput">Audio file (.wav, .mp3, .m4a, .webm, .ogg)</label>
  <input type="file" id="fileInput" accept="audio/*">
  <button id="btnSendFile" class="btn-send" disabled>Send File</button>
</div>

<!-- Result -->
<div class="card">
  <h2>Result</h2>
  <div id="result" class="result-box">
    <div class="label">Transcription</div>
    <div id="resultText"></div>
  </div>
  <div id="resultMeta" class="meta"></div>
</div>

<script>
const $ = id => document.getElementById(id);

let mediaRecorder = null;
let chunks = [];
let recordedBlob = null;
let timerInterval = null;
let startTime = 0;

// ===== Mic =====
$('btnRec').onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    chunks = [];
    recordedBlob = null;
    mediaRecorder = new MediaRecorder(stream, { mimeType: getSupportedMime() });

    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
    mediaRecorder.onstop = () => {
      stream.getTracks().forEach(t => t.stop());
      recordedBlob = new Blob(chunks, { type: mediaRecorder.mimeType });
      const url = URL.createObjectURL(recordedBlob);
      $('audioPreview').src = url;
      $('audioPreview').style.display = 'block';
      $('btnSendRec').disabled = false;
      $('status').textContent = `Recording done — ${(recordedBlob.size / 1024).toFixed(1)} KB`;
    };

    mediaRecorder.start(250);
    startTime = Date.now();
    timerInterval = setInterval(() => {
      $('timer').textContent = ((Date.now() - startTime) / 1000).toFixed(1) + 's';
    }, 100);

    $('btnRec').classList.add('recording');
    $('btnRec').disabled = true;
    $('btnStop').disabled = false;
    $('btnSendRec').disabled = true;
    $('status').textContent = 'Recording...';
  } catch (err) {
    $('status').textContent = 'Mic error: ' + err.message;
  }
};

$('btnStop').onclick = () => {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
    clearInterval(timerInterval);
    $('btnRec').classList.remove('recording');
    $('btnRec').disabled = false;
    $('btnStop').disabled = true;
  }
};

$('btnSendRec').onclick = () => {
  if (!recordedBlob) return;
  const ext = recordedBlob.type.includes('webm') ? 'webm' : recordedBlob.type.includes('ogg') ? 'ogg' : 'wav';
  sendSTT(recordedBlob, `recording.${ext}`);
};

// ===== File =====
$('fileInput').onchange = () => {
  $('btnSendFile').disabled = !$('fileInput').files.length;
};

$('btnSendFile').onclick = () => {
  const file = $('fileInput').files[0];
  if (!file) return;
  sendSTT(file, file.name);
};

// ===== Send =====
async function sendSTT(blob, filename) {
  const base = $('baseUrl').value.replace(/\/+$/, '');
  const lang = $('lang').value;
  const url = `${base}/llm/stt`;

  const form = new FormData();
  form.append('file', blob, filename);
  form.append('lang', lang);

  $('result').classList.remove('show');
  $('resultMeta').textContent = '';
  setButtons(false);
  $('status').textContent = 'Sending...';

  const t0 = performance.now();
  try {
    const resp = await fetch(url, { method: 'POST', body: form });
    const elapsed = ((performance.now() - t0) / 1000).toFixed(2);
    const data = await resp.json();

    if (!resp.ok) {
      $('resultText').textContent = `Error ${resp.status}: ${JSON.stringify(data, null, 2)}`;
    } else if (data.answer) {
      // QAResponse
      $('resultText').textContent = `[STT] ${data.question}\n\n[Answer] ${data.answer}`;
    } else {
      $('resultText').textContent = data.text || JSON.stringify(data, null, 2);
    }

    $('result').classList.add('show');
    $('resultMeta').textContent = `${elapsed}s  ·  ${resp.status} ${resp.statusText}`;
    $('status').textContent = 'Done';
  } catch (err) {
    $('resultText').textContent = err.message;
    $('result').classList.add('show');
    $('status').textContent = 'Request failed';
  } finally {
    setButtons(true);
  }
}

function setButtons(enabled) {
  $('btnSendRec').disabled = !enabled || !recordedBlob;
  $('btnSendFile').disabled = !enabled || !$('fileInput').files.length;
  $('btnRec').disabled = !enabled;
}

function getSupportedMime() {
  for (const mime of ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/mp4']) {
    if (MediaRecorder.isTypeSupported(mime)) return mime;
  }
  return '';
}
</script>
</body>
</html>
