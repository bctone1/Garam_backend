<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AI 상담 챗봇</title>
    <meta name="description" content="가람포스텍 RAG 상담 센터 웹 채팅" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-muted: #f4f6fb;
        --bg-surface: #ffffff;
        --border-subtle: #e2e8f0;
        --border-strong: #cbd5f5;
        --text-primary: #0f172a;
        --text-secondary: #475569;
        --text-tertiary: #94a3b8;
        --accent: #2563eb;
        --accent-soft: #eff6ff;
        --assistant: #ede9fe;
        --assistant-border: rgba(192, 132, 252, 0.4);
        --assistant-text: #5b21b6;
        --danger: #dc2626;
        --success: #16a34a;
        --warning: #f97316;
        --shadow-sm: 0 10px 30px rgba(15, 23, 42, 0.08);
        --shadow-md: 0 16px 40px rgba(30, 64, 175, 0.18);
        --radius-lg: 20px;
      }

      * { box-sizing: border-box; }
      body {
        margin: 0;
        min-height: 100vh;
        background: var(--bg-muted);
        font-family: "Inter", "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: var(--text-primary);
      }
      button { font-family: inherit; }

      .chat-app { min-height: 100vh; display: flex; flex-direction: column; }

      .chat-header {
        background: var(--bg-surface);
        padding: 18px 28px;
        border-bottom: 1px solid var(--border-subtle);
        display: flex; justify-content: space-between; align-items: center; gap: 24px;
        position: sticky; top: 0; z-index: 20;
        box-shadow: 0 4px 18px rgba(15, 23, 42, 0.06);
      }
      .header-left { display: flex; align-items: center; gap: 18px; min-width: 0; }
      .title-group { display: flex; flex-direction: column; gap: 6px; }
      .title-group h1 { margin: 0; font-size: 1.2rem; font-weight: 700; letter-spacing: -0.01em; }
      .session-meta { display: flex; align-items: center; gap: 10px; color: var(--text-secondary); font-size: 0.9rem; }
      .session-id { font-variant-numeric: tabular-nums; font-weight: 600; color: var(--accent); }

      .connection-status {
        display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px;
        border-radius: 999px; font-size: 0.82rem; background: rgba(148, 163, 184, 0.15);
        color: var(--text-secondary); transition: all 0.2s ease;
      }
      .connection-status .status-dot {
        width: 10px; height: 10px; border-radius: 50%; background: var(--text-tertiary);
        box-shadow: 0 0 0 4px rgba(148, 163, 184, 0.25); transition: all 0.2s ease;
      }
      .connection-status.success { background: rgba(34, 197, 94, 0.18); color: var(--success); }
      .connection-status.success .status-dot { background: var(--success); box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.2); }
      .connection-status.error { background: rgba(220, 38, 38, 0.12); color: var(--danger); }
      .connection-status.error .status-dot { background: var(--danger); box-shadow: 0 0 0 4px rgba(220, 38, 38, 0.18); }
      .connection-status.pending { background: rgba(249, 115, 22, 0.12); color: var(--warning); }
      .connection-status.pending .status-dot { background: var(--warning); box-shadow: 0 0 0 4px rgba(249, 115, 22, 0.2); animation: pulse 1.4s infinite ease-in-out; }
      @keyframes pulse { 0%,100%{ transform: scale(1); opacity:.6;} 50%{ transform: scale(1.2); opacity:1;} }

      .header-right { display: flex; align-items: center; gap: 14px; flex-wrap: wrap; justify-content: flex-end; }
      .input-chip { display: flex; align-items: center; gap: 8px; border-radius: 999px; border: 1px solid var(--border-subtle); background: var(--accent-soft); padding: 6px 12px; }
      .input-chip label { font-size: .82rem; color: var(--text-secondary); }
      .input-chip input { border: none; background: transparent; font-size: .86rem; min-width: 200px; color: var(--text-primary); outline: none; }
      .text-input { border-radius: 12px; border: 1px solid var(--border-subtle); background: var(--bg-surface); padding: 8px 12px; font-size: .9rem; outline: none; min-width: 200px; transition: border .2s, box-shadow .2s; }
      .text-input:focus { border-color: rgba(37,99,235,.45); box-shadow: 0 0 0 4px rgba(37,99,235,.12); }

      .ghost-button,.primary-button {
        display:inline-flex; align-items:center; gap:8px; border-radius:999px; padding:10px 18px;
        font-weight:600; font-size:.9rem; cursor:pointer; border:none; transition: transform .15s, box-shadow .15s, opacity .2s;
      }
      .ghost-button { background: rgba(37,99,235,.1); color: var(--accent); }
      .ghost-button:hover { transform: translateY(-1px); box-shadow: 0 8px 18px rgba(37,99,235,.25); }
      .primary-button { background: var(--accent); color:#fff; box-shadow: var(--shadow-sm); }
      .primary-button:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
      .primary-button[disabled]{ opacity:.6; cursor:not-allowed; transform:none; box-shadow:none; }

      .action-buttons { display: flex; flex-direction: column; gap: 10px; }
      .mic-button {
        width:52px; height:52px; padding:0; border-radius:50%; border:1px solid rgba(37,99,235,.25);
        background: var(--bg-surface); color: var(--accent); font-size:1.2rem; font-weight:600;
        align-items:center; justify-content:center; box-shadow:0 6px 16px rgba(37,99,235,.12);
        transition: transform .15s, box-shadow .15s, background .2s, color .2s;
      }
      .mic-button:hover { transform: translateY(-2px); box-shadow: 0 12px 24px rgba(37,99,235,.22); }
      .mic-button.recording { background: rgba(248,113,113,.16); border-color: rgba(248,113,113,.45); color:#dc2626; box-shadow:0 12px 26px rgba(220,38,38,.28); animation: recordingPulse 1.2s infinite ease-in-out; }
      .mic-button.processing { pointer-events:none; background: rgba(37,99,235,.12); color: var(--accent); box-shadow:none; }
      .mic-button[disabled]{ opacity:.6; cursor:not-allowed; transform:none; box-shadow:none; }
      .mic-button .mic-dot{ width:12px; height:12px; border-radius:50%; background: currentColor; display:inline-block; }
      .mic-button .mic-label{ font-size:.7rem; font-weight:600; margin-top:2px; }
      .mic-button .mic-spinner{ width:16px; height:16px; border-radius:50%; border:2px solid rgba(37,99,235,.4); border-top-color: var(--accent); animation: spin .9s linear infinite; }
      .mic-button .mic-content{ display:flex; flex-direction:column; align-items:center; gap:4px; }
      @keyframes recordingPulse { 0%,100%{ transform: translateY(0); box-shadow:0 12px 26px rgba(220,38,38,.18);} 50%{ transform: translateY(-3px); box-shadow:0 16px 38px rgba(220,38,38,.28);} }
      .primary-button .spinner{ width:18px; height:18px; border:2px solid rgba(255,255,255,.6); border-top-color:#fff; border-radius:50%; animation: spin 1s linear infinite; }
      @keyframes spin{ to{ transform: rotate(360deg);} }

      .chat-main { flex:1; overflow-y:auto; padding:28px 18px 34px; }
      .chat-main-inner { max-width:780px; margin:0 auto; display:flex; flex-direction:column; gap:18px; }
      .empty-state {
        text-align:center; padding:80px 16px; color: var(--text-secondary);
        border-radius: var(--radius-lg); border:1px dashed rgba(148,163,184,.35); background: rgba(241,245,249,.6); margin-top:40px;
      }
      .empty-state h2 { margin:12px 0 8px; font-size:1.4rem; }
      .empty-state p { margin:0; font-size:.95rem; }

      .messages { display:flex; flex-direction:column; gap:16px; }
      .message-row { display:flex; gap:14px; align-items:flex-end; }
      .message-row.user { flex-direction: row-reverse; }
      .avatar {
        width:44px; height:44px; border-radius:50%; display:flex; align-items:center; justify-content:center;
        font-weight:600; color:#fff; background: var(--accent); box-shadow:0 10px 22px rgba(37,99,235,.25); flex-shrink:0;
      }
      .message-row.assistant .avatar { background: rgba(109,40,217,.12); color: var(--assistant-text); box-shadow:none; }
      .message-bubble {
        max-width: min(72%, 600px); padding:16px 20px; border-radius:24px; font-size:.98rem; line-height:1.65; letter-spacing:-.01em;
        box-shadow: 0 16px 45px rgba(15,23,42,.1); word-break: break-word; white-space: pre-wrap;
      }
      .message-row.user .message-bubble { background: var(--accent); color:#fff; box-shadow:0 18px 38px rgba(37,99,235,.28); }
      .message-row.assistant .message-bubble { background:#fff; border:1px solid rgba(226,232,240,.85); box-shadow:0 16px 45px rgba(15,23,42,.08); color: var(--text-primary); }
      .message-bubble.typing { display:flex; gap:8px; align-items:center; background: var(--assistant); border:1px solid var(--assistant-border); box-shadow:none; }
      .typing-dot{ width:8px; height:8px; border-radius:50%; background: rgba(91,33,182,.7); animation: blink 1.2s infinite ease-in-out; }
      .typing-dot:nth-child(2){ animation-delay:.2s; } .typing-dot:nth-child(3){ animation-delay:.4s; }
      @keyframes blink { 0%,80%,100%{ opacity:.2; transform: translateY(0);} 40%{ opacity:1; transform: translateY(-4px);} }

      .chat-footer { background:#fff; border-top:1px solid var(--border-subtle); padding:18px 20px 22px; position: sticky; bottom:0; z-index:15; }
      .footer-inner { max-width:780px; margin:0 auto; display:flex; flex-direction:column; gap:14px; }
      .footer-top { display:flex; gap:12px; align-items:flex-end; flex-wrap:wrap; }
      .footer-top textarea{
        flex:1; min-height:90px; max-height:200px; resize:vertical; padding:16px 18px; border-radius:20px;
        border:1px solid rgba(203,213,225,.9); background:#f8fafc; font-size:.96rem; line-height:1.65; transition: border .2s, box-shadow .2s; outline:none;
      }
      .footer-top textarea:focus{ border-color: rgba(37,99,235,.6); box-shadow: 0 0 0 4px rgba(37,99,235,.15); background:#fff; }

      .footer-bottom{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:space-between; }
      .footer-bottom .options{ display:flex; flex-wrap:wrap; gap:10px; font-size:.85rem; color: var(--text-secondary); }
      .option-chip{ display:flex; align-items:center; gap:8px; padding:8px 12px; border-radius:14px; background: rgba(15,23,42,.03); border:1px solid rgba(226,232,240,.9); }
      .option-chip select,.option-chip input{ border:none; background:transparent; font-size:.86rem; outline:none; min-width:70px; }
      .option-chip select{ padding-right:4px; }
      .option-chip input{ width:110px; }

      .hidden{ display:none !important; }
      .toast-container{ position:fixed; top:24px; right:24px; display:flex; flex-direction:column; gap:12px; z-index:1000; }
      .toast{
        min-width:240px; padding:14px 18px; border-radius:16px; color:#fff; font-size:.92rem;
        box-shadow:0 20px 48px rgba(15,23,42,.18); opacity:0; transform: translateY(-12px); transition: opacity .3s, transform .3s;
      }
      .toast.visible{ opacity:1; transform: translateY(0); }
      .toast.info{ background: rgba(15,23,42,.92); }
      .toast.success{ background: rgba(22,163,74,.92); }
      .toast.error{ background: rgba(220,38,38,.92); }
      .toast.warning{ background: rgba(249,115,22,.92); }

      @media (max-width: 960px){
        .chat-header{ flex-direction:column; align-items:stretch; }
        .header-right{ justify-content:flex-start; }
        .footer-top{ flex-direction:column; }
        .primary-button{ align-self:flex-end; }
      }
      @media (max-width: 640px){
        .chat-header{ padding:16px; }
        .chat-main{ padding:24px 12px 30px; }
        .footer-inner{ padding:0; }
        .option-chip input{ width:90px; }
      }
    </style>
  </head>
  <body>
    <div class="chat-app">
      <header class="chat-header">
        <div class="header-left">
          <button class="ghost-button" id="newSessionButton">+ 새 대화</button>
          <div class="title-group">
            <h1>AI 상담 챗봇</h1>
            <div class="session-meta">
              <span>세션</span>
              <span class="session-id" id="sessionId">-</span>
              <span class="connection-status" id="connectionStatus">
                <span class="status-dot"></span>
                <span id="connectionStatusText">연결 대기</span>
              </span>
            </div>
          </div>
        </div>
        <div class="header-right">
          <input class="text-input" id="sessionTitleInput" type="text" placeholder="세션 제목을 입력하세요" autocomplete="off"/>
          <div class="input-chip">
            <label for="apiBaseInput">API</label>
            <input id="apiBaseInput" type="text" placeholder="http://localhost:5002" autocomplete="off" />
          </div>
          <button class="ghost-button" id="checkConnectionButton">연결 확인</button>
        </div>
      </header>

      <main class="chat-main" id="chatMain">
        <div class="chat-main-inner">
          <div class="empty-state" id="emptyState">
            <div style="font-size: 48px">💬</div>
            <h2>대화를 시작해보세요</h2>
            <p>문의하고 싶은 내용을 입력하면 AI 상담원이 바로 답변해 드립니다.</p>
          </div>
          <div class="messages" id="messages"></div>
        </div>
      </main>

      <footer class="chat-footer">
        <div class="footer-inner">
          <div class="footer-top">
            <textarea id="messageInput" placeholder="메시지를 입력하고 Enter 키로 전송해보세요. 줄바꿈은 Shift + Enter"></textarea>
            <div class="action-buttons">
              <button class="ghost-button mic-button" id="micButton" type="button" aria-pressed="false">
                <span class="mic-content">
                  <span aria-hidden="true">🎤</span>
                  <span class="mic-label">음성</span>
                </span>
              </button>
              <button class="primary-button" id="sendButton" type="button">
                <span>전송</span>
              </button>
            </div>
          </div>
          <div class="footer-bottom">
            <div class="options">
              <div class="option-chip">
                <span>검색 Top-K</span>
                <select id="topKSelect">
                  <option value="3">3</option>
                  <option value="5" selected>5</option>
                  <option value="7">7</option>
                  <option value="10">10</option>
                </select>
              </div>
              <div class="option-chip">
                <span>지식베이스</span>
                <select id="knowledgeSelect">
                  <option value="">전체</option>
                </select>
              </div>
            </div>
            <div class="options">
              <div class="option-chip">
                <span>응답 언어</span>
                <span>한국어</span>
              </div>
            </div>
          </div>
        </div>
      </footer>
    </div>
    <div class="toast-container" id="toastContainer"></div>

    <script type="module">
      const state = {
        baseUrl: "",
        sessionId: null,
        isSending: false,
        typingEl: null,
        previewUpdated: false,
        isRecording: false,
      };

      const elements = {
        sessionId: document.getElementById("sessionId"),
        sessionTitle: document.getElementById("sessionTitleInput"),
        connectionStatus: document.getElementById("connectionStatus"),
        connectionStatusText: document.getElementById("connectionStatusText"),
        apiBaseInput: document.getElementById("apiBaseInput"),
        checkConnectionButton: document.getElementById("checkConnectionButton"),
        newSessionButton: document.getElementById("newSessionButton"),
        messageInput: document.getElementById("messageInput"),
        sendButton: document.getElementById("sendButton"),
        messages: document.getElementById("messages"),
        emptyState: document.getElementById("emptyState"),
        toastContainer: document.getElementById("toastContainer"),
        topKSelect: document.getElementById("topKSelect"),
        knowledgeSelect: document.getElementById("knowledgeSelect"),
        chatMain: document.getElementById("chatMain"),
        micButton: document.getElementById("micButton"),
      };

      // STT 설정
      const STT_ENDPOINT = "/llm/clova_stt";
      const STT_LANG = "Kor";

      const STORAGE_KEYS = { BASE_URL: "chat_api_base_url", SESSION_TITLE: "chat_session_title" };

      function sanitizeBaseUrl(value) { return value.trim().replace(/\/+$/, ""); }
      function scrollToBottom() {
        requestAnimationFrame(() => {
          elements.chatMain.scrollTo({ top: elements.chatMain.scrollHeight, behavior: "smooth" });
        });
      }
      function showToast(message, variant = "info", duration = 4000) {
        const toast = document.createElement("div");
        toast.className = `toast ${variant}`; toast.textContent = message;
        elements.toastContainer.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add("visible"));
        setTimeout(() => { toast.classList.remove("visible"); setTimeout(() => toast.remove(), 300); }, duration);
      }
      function setConnectionStatus(type, message) {
        elements.connectionStatus.classList.remove("success", "error", "pending");
        if (type) elements.connectionStatus.classList.add(type);
        elements.connectionStatusText.textContent = message;
      }
      function updateSessionDisplay() { elements.sessionId.textContent = state.sessionId ? `#${state.sessionId}` : "-"; }
      function updateEmptyState() {
        const hasMessages = elements.messages.children.length > 0;
        elements.emptyState.classList.toggle("hidden", hasMessages);
      }
      function setSendingState(isSending) {
        state.isSending = isSending; elements.sendButton.disabled = isSending; elements.messageInput.disabled = isSending;
        elements.sendButton.innerHTML = isSending ? '<span class="spinner"></span><span>전송 중...</span>' : "<span>전송</span>";
      }

      // ── 녹음/STT 상태
      const audioState = { stream: null, recorder: null, chunks: [], timeoutId: null, isProcessing: false };

      function updateMicButtonUI() {
        if (!elements.micButton) return;
        elements.micButton.classList.toggle("recording", state.isRecording);
        elements.micButton.classList.toggle("processing", audioState.isProcessing);
        if (audioState.isProcessing) {
          elements.micButton.innerHTML = `
            <span class="mic-content">
              <span class="mic-spinner" aria-hidden="true"></span>
              <span class="mic-label">처리 중</span>
            </span>`;
          elements.micButton.setAttribute("aria-pressed", "false");
          elements.micButton.disabled = true;
          return;
        }
        if (state.isRecording) {
          elements.micButton.innerHTML = `
            <span class="mic-content">
              <span class="mic-dot" aria-hidden="true"></span>
              <span class="mic-label">녹음 중</span>
            </span>`;
          elements.micButton.setAttribute("aria-pressed", "true");
        } else {
          elements.micButton.innerHTML = `
            <span class="mic-content">
              <span aria-hidden="true">🎤</span>
              <span class="mic-label">음성</span>
            </span>`;
          elements.micButton.setAttribute("aria-pressed", "false");
        }
        elements.micButton.disabled = false;
      }

      async function ensureAudioStream() {
        if (audioState.stream) return audioState.stream;
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error("이 브라우저에서는 마이크를 사용할 수 없습니다.");
        }
        audioState.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        return audioState.stream;
      }

      function stopRecording() {
        if (audioState.timeoutId) { clearTimeout(audioState.timeoutId); audioState.timeoutId = null; }
        if (audioState.recorder && audioState.recorder.state === "recording") audioState.recorder.stop();
      }

      // [교체] handleRecordingStop 전체
      async function handleRecordingStop(mimeType) {
        if (audioState.timeoutId) { clearTimeout(audioState.timeoutId); audioState.timeoutId = null; }
        state.isRecording = false; updateMicButtonUI();
        if (!audioState.chunks.length) { audioState.recorder = null; return; }

        audioState.isProcessing = true; updateMicButtonUI();

        const blob = new Blob(audioState.chunks, { type: mimeType || "audio/webm" });
        const extension = mimeType && mimeType.includes("mp4") ? "mp4"
                        : mimeType && mimeType.includes("mpeg") ? "mp3"
                        : "webm";

        const formData = new FormData();
        formData.append("file", blob, `recording.${extension}`);
        formData.append("lang", STT_LANG);

        try {
          if (!state.baseUrl) throw new Error("API 주소를 먼저 설정해주세요.");

          const response = await fetch(`${state.baseUrl}${STT_ENDPOINT}`, { method: "POST", body: formData });
          if (!response.ok) {
            const message = await parseError(response);
            throw new Error(message || "음성 인식 요청에 실패했습니다.");
          }
          const data = await response.json();
          const text = (data?.text || data?.result?.text || "").trim();

          if (text) {
            elements.messageInput.value = text;
            elements.messageInput.focus();
            await handleSend(); // 여기서 QA 호출
          } else {
            showToast("음성을 인식하지 못했습니다.", "warning");
          }
        } catch (error) {
          console.error("STT 오류", error);
          showToast(error.message || "음성을 텍스트로 변환하지 못했습니다.", "error");
        } finally {
          audioState.isProcessing = false;
          audioState.chunks = [];
          audioState.recorder = null;
          updateMicButtonUI();
        }
      }

      async function startRecording() {
        if (!state.baseUrl) { showToast("먼저 API 주소를 설정해주세요.", "warning"); return; }
        try {
          const stream = await ensureAudioStream();
          audioState.chunks = [];
          const mime = MediaRecorder.isTypeSupported("audio/webm") ? "audio/webm" : undefined;
          const recorder = mime ? new MediaRecorder(stream, { mimeType: mime }) : new MediaRecorder(stream);
          recorder.ondataavailable = (event) => { if (event.data && event.data.size > 0) audioState.chunks.push(event.data); };
          recorder.onstop = () => handleRecordingStop(recorder.mimeType);
          recorder.start();
          audioState.recorder = recorder;
          state.isRecording = true; updateMicButtonUI();
          audioState.timeoutId = window.setTimeout(() => {
            if (audioState.recorder && audioState.recorder.state === "recording") audioState.recorder.stop();
          }, 6000);
        } catch (error) {
          console.error("녹음 시작 오류", error);
          showToast(error.message || "마이크를 활성화하지 못했습니다.", "error");
          state.isRecording = false; updateMicButtonUI();
        }
      }

      function createAvatar(role) {
        const avatar = document.createElement("div");
        avatar.className = "avatar";
        avatar.textContent = role === "user" ? "나" : "AI";
        return avatar;
      }
      function appendMessage(role, content) {
        const row = document.createElement("div");
        row.className = `message-row ${role === "user" ? "user" : "assistant"}`;
        const avatar = createAvatar(role);
        const bubble = document.createElement("div");
        bubble.className = "message-bubble";
        bubble.textContent = content;
        row.appendChild(avatar); row.appendChild(bubble);
        elements.messages.appendChild(row);
        updateEmptyState(); scrollToBottom();
        return row;
      }
      function showTypingIndicator() {
        if (state.typingEl) return state.typingEl;
        const row = document.createElement("div");
        row.className = "message-row assistant";
        const avatar = createAvatar("assistant");
        const bubble = document.createElement("div");
        bubble.className = "message-bubble typing";
        bubble.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
        row.appendChild(avatar); row.appendChild(bubble);
        elements.messages.appendChild(row);
        state.typingEl = row; updateEmptyState(); scrollToBottom();
        return row;
      }
      function hideTypingIndicator() {
        if (state.typingEl && state.typingEl.parentElement) state.typingEl.parentElement.removeChild(state.typingEl);
        state.typingEl = null; updateEmptyState();
      }

      async function parseError(response) {
        const fallback = `${response.status} ${response.statusText}`.trim();
        try {
          const data = await response.clone().json();
          if (typeof data === "string") return data;
          if (data.detail) {
            if (typeof data.detail === "string") return data.detail;
            if (Array.isArray(data.detail)) return data.detail.map((i)=> i.msg||i.message|| (typeof i==="string"? i: JSON.stringify(i))).join(", ");
            if (typeof data.detail === "object") return data.detail.message || JSON.stringify(data.detail);
          }
          if (data.message) return data.message;
          return JSON.stringify(data);
        } catch {
          try { const text = await response.clone().text(); return text || fallback; } catch { return fallback || "요청 처리에 실패했습니다."; }
        }
      }

      async function loadKnowledgeOptions() {
        if (!state.baseUrl) return;
        try {
          const response = await fetch(`${state.baseUrl}/knowledge?offset=0&limit=100`);
          if (!response.ok) return;
          const items = await response.json();
          elements.knowledgeSelect.innerHTML = '<option value="">전체</option>';
          items.forEach((item) => {
            const option = document.createElement("option");
            const label = item.original_name || item.preview || `지식베이스 ${item.id}`;
            option.value = String(item.id);
            option.textContent = `#${item.id} · ${label}`;
            elements.knowledgeSelect.appendChild(option);
          });
        } catch (error) { console.error("지식베이스 목록을 불러오지 못했습니다.", error); }
      }

      async function checkConnection() {
        if (!state.baseUrl) { showToast("API 주소를 입력해주세요.", "warning"); return; }
        setConnectionStatus("pending", "연결 확인 중...");
        try {
          const response = await fetch(`${state.baseUrl}/chat/sessions?limit=1`);
          if (!response.ok) { const message = await parseError(response); throw new Error(message); }
          setConnectionStatus("success", "API 연결 성공"); showToast("API에 정상적으로 연결되었습니다.", "success");
          await loadKnowledgeOptions();
        } catch (error) {
          console.error(error);
          setConnectionStatus("error", "API 연결 실패");
          showToast(error.message || "API 연결에 실패했습니다.", "error");
        }
      }

      async function ensureSession() {
        if (state.sessionId) return state.sessionId;
        if (!state.baseUrl) { showToast("API 주소를 먼저 설정해주세요.", "warning"); throw new Error("API base URL is missing"); }
        const title = (elements.sessionTitle.value || "웹 채팅 세션").trim();
        try {
          const response = await fetch(`${state.baseUrl}/chat/sessions`, {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ title, preview: "", resolved: false }),
          });
          if (!response.ok) { const message = await parseError(response); throw new Error(message); }
          const data = await response.json();
          state.sessionId = data.id; state.previewUpdated = false;
          updateSessionDisplay(); showToast(`새 채팅 세션이 생성되었습니다. (#${state.sessionId})`, "success", 3000);
          return state.sessionId;
        } catch (error) { showToast(error.message || "세션 생성에 실패했습니다.", "error"); throw error; }
      }

      async function storeMessage(role, content, latencyMs = null) {
        if (!state.sessionId) return;
        try {
          const response = await fetch(`${state.baseUrl}/chat/sessions/${state.sessionId}/messages`, {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ session_id: state.sessionId, role, content, response_latency_ms: latencyMs }),
          });
          if (!response.ok) { const message = await parseError(response); throw new Error(message); }
        } catch (error) { console.warn("메시지 저장 실패", error); showToast(error.message || "메시지 저장에 실패했습니다.", "warning"); }
      }

      async function updatePreviewIfNeeded(userMessage) {
        if (state.previewUpdated || !state.sessionId) return;
        try {
          const response = await fetch(`${state.baseUrl}/chat/sessions/${state.sessionId}`, {
            method: "PATCH", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ title: (elements.sessionTitle.value || "웹 채팅 세션").trim(), preview: userMessage.slice(0, 120) }),
          });
          if (response.ok) state.previewUpdated = true;
        } catch (error) { console.warn("세션 미리보기 업데이트 실패", error); }
      }

      // [ADDED] 스트리밍 호출
      async function requestAssistantAnswerStream(question) {
        const topK = Number(elements.topKSelect.value) || 5;
        const knowledgeValue = elements.knowledgeSelect.value;
        const payload = {
          question,
          top_k: topK,
          knowledge_id: knowledgeValue ? Number(knowledgeValue) : null,
          session_id: state.sessionId,
          style: "friendly",
        };

        const response = await fetch(`${state.baseUrl}/llm/qa/stream`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok) {
          const message = await parseError(response);
          throw new Error(message || "스트리밍 요청 실패");
        }
        console.log(response);
        return response.body.getReader(); // 스트림 리더 반환
      }

      async function handleSend() {
        if (state.isSending) return;
        const message = elements.messageInput.value.trim();
        if (!message) { showToast("메시지를 입력해주세요.", "warning"); return; }
        elements.messageInput.value = ""; setSendingState(true);
        try { await ensureSession(); } catch { setSendingState(false); return; }

        appendMessage("user", message);
        await updatePreviewIfNeeded(message);
        await storeMessage("user", message);

        // 타이핑 표시 후 첫 청크 수신 시 교체
        showTypingIndicator();
        const start = performance.now();

        try {
          const reader = await requestAssistantAnswerStream(message);
          const decoder = new TextDecoder("utf-8");
          let fullText = "";
          let assistantRow = null;
          let assistantBubble = null;

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            if (!assistantRow) {
              hideTypingIndicator();
              assistantRow = appendMessage("assistant", "");
              assistantBubble = assistantRow.querySelector(".message-bubble");
            }
            fullText += chunk;
            assistantBubble.textContent = fullText;
            scrollToBottom();
          }

          const latency = Math.round(performance.now() - start);
          await storeMessage("assistant", fullText || "응답이 비어 있습니다.", latency);
        } catch (error) {
          hideTypingIndicator();
          console.error("LLM 스트리밍 오류", error);
          appendMessage("assistant", error.message || "답변을 가져오지 못했습니다.");
          showToast(error.message || "답변 생성 중 오류가 발생했습니다.", "error");
        } finally {
          setSendingState(false);
        }
      }

      function resetConversation({ keepBase = true } = {}) {
        if (!keepBase) {
          state.baseUrl = ""; elements.apiBaseInput.value = ""; localStorage.removeItem(STORAGE_KEYS.BASE_URL);
        }
        state.sessionId = null; state.previewUpdated = false; updateSessionDisplay();
        elements.messages.innerHTML = ""; hideTypingIndicator(); updateEmptyState(); setSendingState(false);
      }

      // 이벤트 바인딩
      elements.sendButton.addEventListener("click", handleSend);

      elements.messageInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) { event.preventDefault(); handleSend(); }
      });
      if (elements.micButton) {
        elements.micButton.addEventListener("click", () => {
          if (audioState.isProcessing) return;
          if (state.isRecording) stopRecording(); else startRecording();
        });
      }
      elements.checkConnectionButton.addEventListener("click", () => { checkConnection(); });
      elements.newSessionButton.addEventListener("click", async () => {
        resetConversation();
        if (!state.baseUrl) { showToast("API 주소를 먼저 설정해주세요.", "warning"); return; }
        try { await ensureSession(); } catch {}
      });
      elements.apiBaseInput.addEventListener("change", () => {
        const value = sanitizeBaseUrl(elements.apiBaseInput.value);
        state.baseUrl = value; elements.apiBaseInput.value = value;
        if (value) localStorage.setItem(STORAGE_KEYS.BASE_URL, value); else localStorage.removeItem(STORAGE_KEYS.BASE_URL);
        resetConversation(); setConnectionStatus("", "연결 대기");
      });
      elements.sessionTitle.addEventListener("change", () => {
        const value = elements.sessionTitle.value.trim();
        if (value) localStorage.setItem(STORAGE_KEYS.SESSION_TITLE, value); else localStorage.removeItem(STORAGE_KEYS.SESSION_TITLE);
      });

      function restorePreferences() {
        const savedBase = localStorage.getItem(STORAGE_KEYS.BASE_URL) || "http://localhost:5002";
        state.baseUrl = sanitizeBaseUrl(savedBase); elements.apiBaseInput.value = state.baseUrl;
        const savedTitle = localStorage.getItem(STORAGE_KEYS.SESSION_TITLE) || "웹 채팅 세션";
        elements.sessionTitle.value = savedTitle;
      }

      restorePreferences();
      updateEmptyState();
      updateSessionDisplay();
      updateMicButtonUI();
      if (state.baseUrl) { checkConnection(); }
    </script>
  </body>
</html>
